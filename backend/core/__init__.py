# -*- coding: utf-8 -*-
"""
Core AI Agent Module - Request detection and processing
Senior Python Developer - Reusable Core Logic
"""

import re
import logging
from typing import Tuple

logger = logging.getLogger(__name__)


class AIAgent:
    """Professional AI Agent for request type detection and processing"""
    
    # Request type patterns
    PATTERNS = {
        'fact_check': [
            r'\b(is it|are|true|false|verify|fact.?check|correct|accurate|real|fake)\b',
            r'\b(claim|myth|rumor|hoax|misinformation|false claim)\b',
            r'^(is|are|do|does|can|will|should)\s',
            r'\b(true or false|yes or no|correct or incorrect)\b',
        ],
        'ai_detection': [
            r'\b(ai|artificial intelligence|chatgpt|gpt|generated|wrote by)\b',
            r'\b(detect|identify|find|check if).*\b(ai|artificial|machine|generated)\b',
            r'\b(ai.?generated|ai.?written|written by ai|generated by ai)\b',
        ],
    }
    
    @staticmethod
    def detect_request_type(text: str) -> str:
        """
        Detect request type based on keywords and patterns
        
        Args:
            text: User input text
            
        Returns:
            'fact_check', 'ai_detection', or 'general_chat'
        """
        text_lower = text.lower().strip()
        
        # Score each type
        scores = {
            'fact_check': 0,
            'ai_detection': 0,
        }
        
        for req_type, patterns in AIAgent.PATTERNS.items():
            for pattern in patterns:
                if re.search(pattern, text_lower):
                    scores[req_type] += 1
        
        # Determine highest scoring type
        max_score = max(scores.values())
        
        if max_score == 0:
            return 'general_chat'
        
        for req_type, score in scores.items():
            if score == max_score:
                logger.debug(f"Request type detected: {req_type} (score: {score})")
                return req_type
        
        return 'general_chat'
    
    @staticmethod
    def validate_input(text: str, constraints: dict = None) -> Tuple[bool, str]:
        """
        Validate user input
        
        Args:
            text: User input text
            constraints: Validation constraints (min_length, max_length, etc.)
            
        Returns:
            Tuple of (is_valid, message)
        """
        if constraints is None:
            constraints = {'min_length': 1, 'max_length': 5000}
        
        text = text.strip() if text else ""
        
        # Check if empty
        if not text:
            return False, "❌ Text input is required"
        
        # Check minimum length
        min_len = constraints.get('min_length', 1)
        if len(text) < min_len:
            return False, f"❌ Text must be at least {min_len} characters"
        
        # Check maximum length
        max_len = constraints.get('max_length', 5000)
        if len(text) > max_len:
            return False, f"❌ Text exceeds {max_len} character limit"
        
        return True, text
    
    @staticmethod
    def get_system_prompt(request_type: str, prompts: dict) -> str:
        """
        Get system prompt for request type
        
        Args:
            request_type: Type of request
            prompts: Dictionary of prompts
            
        Returns:
            System prompt string
        """
        return prompts.get(request_type, prompts.get('general_chat', ""))


class RequestProcessor:
    """Process and format requests and responses"""
    
    @staticmethod
    def format_response(result: str, request_type: str, metadata: dict = None) -> dict:
        """
        Format AI response in consistent structure
        
        Args:
            result: AI generated result
            request_type: Type of request
            metadata: Additional metadata
            
        Returns:
            Formatted response dictionary
        """
        response = {
            'success': True,
            'result': result,
            'type': request_type,
        }
        
        if metadata:
            response.update(metadata)
        
        return response
    
    @staticmethod
    def format_error(error_message: str, error_code: str = None) -> dict:
        """
        Format error response
        
        Args:
            error_message: Error message
            error_code: Error code
            
        Returns:
            Formatted error dictionary
        """
        return {
            'success': False,
            'error': error_message,
            'error_code': error_code or 'UNKNOWN_ERROR',
        }
